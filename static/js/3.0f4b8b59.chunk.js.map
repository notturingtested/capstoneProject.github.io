{"version":3,"sources":["resources/charts/VizConstants.js","resources/charts/VegaViz.js","resources/charts/ForceDirected/ForceDirectedMarks.js","resources/charts/ForceDirected/ForceDirectedScales.js","resources/charts/ForceDirected/ForceDirectedSignals.js","resources/charts/ForceDirected/ForceDirectedVegaDataFormatter.js","resources/charts/VizTooltip.js","resources/charts/ForceDirected/ForceDirectedExpressionFunctions.js","resources/d3.js","resources/charts/ForceDirected/ForceDirectedTooltip.js","resources/charts/ForceDirected/ForceDirected.js"],"names":["CONSTANTS","VegaViz","opts","this","_setOpts","a","data","isUnitTest","el","innerHTML","JSON","stringify","window","refresh","method","args","_opts","apply","value","options","optionOverrides","_numberFormatter","Object","assign","_callOptsHandler","ids","locale","l10n","numberFormatter","metricFormatter","MetricFormatter","format","bind","ForceDirectedMarks","_","compact","getNodeMarks","getNodeTextMarks","getLinkMarks","name","type","zindex","from","on","trigger","modify","values","encode","enter","fill","scale","field","stroke","tooltip","signal","size","update","cursor","transform","getForceTransform","iterations","restart","static","forces","force","x","y","radius","strength","links","distance","align","baseline","fontSize","text","interactive","chartID","strokeWidth","require","shape","sourceX","sourceY","targetX","targetY","getMarks","ForceDirectedScales","getColorScales","getVolumeScale","domain","range","scheme","zero","getScales","ForceDirectedSignals","getCx","getCy","getNodeRadius","getNodeCharge","getLinkDistance","getStatic","getFix","getClicked","getNode","getRestart","allowSignalBinds","input","min","max","step","description","events","getSignals","ForceDirectedVegaDataFormatter","formattedData","aggregateData","formatDataForVega","VizTooltip","targetRect","boundaryRect","content","orientation","padding","parent","id","tipDiv","selectAll","cx","width","cy","height","dx","dy","tipDivEnter","append","classed","attr","style","select","html","node","appendChild","tipDivNotch","tipNode","Math","offsetWidth","offsetHeight","top","left","clamp","val","setTopAndLeft","_orientation","tempLeft","tempTop","nextViableOrientation","orientationPreference","invalidOrientations","push","filter","indexOf","determineNextViableOrientation","dimensions","LineExpressionFunctions","vega","chartsOpts","allCharts","expressionFunction","getAllCharts","link","chartOpts","topEdges","getTopVolumeEdges","i","length","source","datum","target","swatchColors","volume","adjustedVolume","parseInt","round","d3","ForceDirectedTooltip","item","bounds","x2","x1","y2","y1","getItemWidth","getItemHeight","event","currentTooltip","layerY","layerX","xy","sqrt","pow","abs","handler","isEqualTooltip","mark","container","_el","vegaType","checkIfOverNode","tooltipCancelId","setTimeout","removeTooltip","nodeTooltipContent","clearTimeout","showTooltip","error","getComputedStylePropertyValue","property","getComputedStyle","document","body","getPropertyValue","trim","vegaEmbed","ForceDirectedExpressionFunctions","registerStaticExpressions","ForceDirected","guid","create","setupChart","currentRenderId","cancelPendingRenders","newPendingRenderId","destroy","validate","existing","querySelector","remove","vegaContainer","createElement","classList","add","shouldShowLoadingState","showLoadingState","sleep","chartOptions","clientHeight","clientWidth","ForceDirectedVegaFormatter","forceDirectedTooltip","tooltipCallback","show","registerChartInstance","vegaSpec","getChartConfig","embedOpts","vegaView","isCancelledRender","view","finalize","lastRenderId","renderId","$schema","autosize","contains","background","fontFamilies","axisLabelColor","axisGridColor","vizBackgroundColor","signals","marks","scales","config","right","bottom","ChartFactory","registerChart"],"mappings":"iNAEIA,E,qHCKiBC,E,WAEpB,aAAwB,IAAZC,EAAW,uDAAJ,GAAI,oBACtBC,KAAKC,SAASF,G,+EAGf,wCAAAG,EAAA,sDAAWH,EAAX,+BAAkB,GAEjBC,KAAKC,SAASF,GAFf,gD,4EAMA,SAASI,GACR,QAAKA,KAIDH,KAAKI,aACRJ,KAAKK,GAAGC,UAAYC,KAAKC,UAAUL,EAAM,KAAM,IACxC,M,sBAMT,WACC,QAASM,OAAOL,a,qBAIjB,c,sBAKA,WACCJ,KAAKU,Y,qBAGN,c,8BAIA,SAAiBC,EAAQC,GACxB,GAAKZ,KAAKa,MAAMF,GAGhB,OAAOX,KAAKa,MAAMF,GAAQG,MAAM,KAAMF,K,0BAGvC,SAAaG,GAA8C,IAAvCC,EAAsC,uDAA5B,GAAIC,EAAwB,uDAAN,KACnD,OAAOjB,KAAKkB,iBAAiBH,EAAOE,EAAkBE,OAAOC,OAAO,GAAIJ,EAASC,GAAmBD,K,yBAGrG,WAAsB,IAAD,uBAANJ,EAAM,yBAANA,EAAM,gBACpB,OAAOZ,KAAKqB,iBAAiB,cAAeT,K,wBAG7C,WAAqB,IAAD,uBAANA,EAAM,yBAANA,EAAM,gBACnB,OAAOZ,KAAKqB,iBAAiB,aAAcT,K,2BAG5C,WAAwB,IAAD,uBAANA,EAAM,yBAANA,EAAM,gBACtB,OAAOZ,KAAKqB,iBAAiB,gBAAiBT,K,sBAG/C,WAAmB,IAAD,uBAANA,EAAM,yBAANA,EAAM,gBACjB,OAAOZ,KAAKqB,iBAAiB,WAAYT,K,gCAG1C,SAAmBU,M,6BAInB,c,qBAIA,WACKtB,KAAKK,KAAOL,KAAKI,aACpBJ,KAAKK,GAAGC,UAAY,IAFL,2BAANM,EAAM,yBAANA,EAAM,gBAIhB,OAAOZ,KAAKqB,iBAAiB,UAAWT,K,kBAGzC,WACC,OAAOZ,KAAKa,MAAMU,QAAU,U,sBAG7B,WACC,OAAOvB,KAAKa,MAAMW,MAAQ,K,sBAkB3B,WAAqB,IAAZzB,EAAW,uDAAJ,GAMf,GAJEC,KAAKK,GAAKN,EAAKM,GAIbN,EAAK0B,gBACRzB,KAAKkB,iBAAmBnB,EAAK0B,qBACvB,IAAKzB,KAAKkB,iBAAkB,CAClC,IAAIQ,EAAkB,IAAIC,kBAC1B3B,KAAKkB,iBAAmBQ,EAAgBE,OAAOC,KAAKH,GAErD1B,KAAKa,MAAQd,M,KC3HM+B,E,wFACnB,SAAS/B,GAOT,OANcgC,IAAEC,QAAQ,CACtBhC,KAAKiC,aAAalC,GAClBC,KAAKkC,iBAAiBnC,GACtBC,KAAKmC,aAAapC,O,0BAMpB,SAAaA,GACX,MAAO,CACLqC,KAAM,QACNC,KAAM,SACNC,OAAQ,EACRC,KAAM,CACJpC,KAAM,aAERqC,GAAI,CAAC,CACDC,QAAS,MACTC,OAAQ,OACRC,OAAQ,sEAEV,CACEF,QAAS,OACTC,OAAQ,OACRC,OAAQ,yBAGZC,OAAQ,CACNC,MAAO,CACLC,KAAM,CACJC,MAAO,QACPC,MAAO,SAETC,OAAQ,CACNlC,MAAO,SAETmC,QAAS,CACPC,OAAQ,wDAEVC,KAAM,CACJL,MAAO,OACPC,MAAO,oBAGXK,OAAQ,CAINC,OAAQ,CACNvC,MAAO,aAKbwC,UAAW,CAACvD,KAAKwD,kBAAkBzD,O,+BAIvC,SAAkBA,GAChB,MAAO,CACLsC,KAAM,QACNoB,WAAY,IACZC,QAAS,CACPP,OAAQ,WAEVQ,OAAQ,CACNR,OAAQ,UAEVA,OAAQ,QACRS,OAAQ,CAAC,CACLC,MAAO,SACPC,EAAG,CACDX,OAAQ,MAEVY,EAAG,CACDZ,OAAQ,OAGZ,CACEU,MAAO,UACPG,OAAQ,CACNb,OAAQ,eAGZ,CACEU,MAAO,QACPI,SAAU,CACRd,OAAQ,eAGZ,CACEU,MAAO,OACPK,MAAO,YACPC,SAAU,CACRhB,OAAQ,qB,8BAOlB,SAAiBpD,GACf,MAAO,CACLsC,KAAM,OACND,KAAM,YACNG,KAAM,CAACpC,KAAM,SACbmC,OAAQ,EACRM,OAAQ,CACNC,MAAO,CACLuB,MAAO,CAACrD,MAAO,UACfsD,SAAU,CAACtD,MAAO,UAClBuD,SAAU,CAACvD,MAAO,IAClB+B,KAAM,CAAC/B,MAAO,UAEhBsC,OAAQ,CACNkB,KAAM,CAACpB,OAAQ,oGACfW,EAAG,CAACX,OAAQ,WACZY,EAAG,CAACZ,OAAQ,WACZD,QAAS,CACPC,OAAQ,oEAEVG,OAAQ,CACNvC,MAAO,gB,0BAOjB,SAAahB,GACX,MAAO,CACLsC,KAAM,OACNE,KAAM,CACJpC,KAAM,aAERqE,aAAa,EACb5B,OAAQ,CACNS,OAAQ,CACNJ,OAAQ,CACNE,OAAO,uDAAD,OAAyDpD,EAAK0E,QAA9D,kBAERC,YAAa,CACX1B,MAAO,kBAETE,QAAS,CAACnC,MAAO,UACjBuB,OAAQ,CAACa,OAAO,+CAAD,OAAiDpD,EAAK0E,QAAtD,cAGnBlB,UAAW,CAAC,CACVlB,KAAM,WACNsC,QAAS,CACPxB,OAAQ,SAEVyB,MAAO,QACPC,QAAS,iBACTC,QAAS,iBACTC,QAAS,iBACTC,QAAS,uB,qBAKf,SAAcjF,GAEd,OADiB,IAAIC,MACLiF,SAASlF,O,KCvKNmF,E,yFACnB,SAAUnF,GACV,OAAOgC,IAAEC,QAAQ,CACbhC,KAAKmF,eAAepF,GACpBC,KAAKoF,eAAerF,O,4BAIxB,SAAeA,GACb,MAAO,CACLqC,KAAM,QACNC,KAAM,UACNgD,OAAQ,CACNlF,KAAM,YACN6C,MAAO,SAETsC,MAAO,CACLC,OAAQ,kB,4BAKd,SAAexF,GACb,MAAO,CACLqC,KAAM,OACNiD,OAAQ,CAAClF,KAAM,YAAa6C,MAAO,mBACnCwC,MAAM,EACNF,MAAO,CAAC,IAAK,S,qBAIjB,SAAcvF,GAEd,OADiB,IAAIC,MACLyF,UAAU1F,O,KCjCP2F,E,0FACnB,SAAW3F,GACT,OAAOgC,IAAEC,QAAQ,CACfhC,KAAK2F,MAAM5F,GACXC,KAAK4F,MAAM7F,GACXC,KAAK6F,cAAc9F,GACnBC,KAAK8F,cAAc/F,GACnBC,KAAK+F,gBAAgBhG,GACrBC,KAAKgG,UAAUjG,GACfC,KAAKiG,OAAOlG,GACZC,KAAKkG,WAAWnG,GAChBC,KAAKmG,QAAQpG,GACbC,KAAKoG,WAAWrG,O,mBAIpB,SAAMA,GACJ,MAAO,CACLqC,KAAM,KACNiB,OAAQ,e,mBAIZ,SAAMtD,GACJ,MAAO,CACLqC,KAAM,KACNiB,OAAQ,gB,2BAIZ,SAActD,GAQZ,MAAO,CACLqC,KAAM,aACNrB,MAAO,GACPc,KAAM9B,EAAKsG,iBAVA,CACXC,MAAO,QACPC,IAAK,GACLC,IAAK,GACLC,KAAM,GAM+B,Q,2BAIzC,SAAc1G,GAQZ,MAAO,CACLqC,KAAM,aACNrB,OAAQ,GACRc,KAAM9B,EAAKsG,iBAVA,CACTC,MAAO,QACPC,KAAM,IACNC,IAAK,GACLC,KAAM,GAM6B,Q,6BAIzC,SAAgB1G,GAQd,MAAO,CACLqC,KAAM,eACNrB,MAAO,GACPc,KAAM9B,EAAKsG,iBAVA,CACXC,MAAO,QACPC,IAAK,EACLC,IAAK,IACLC,KAAM,GAM+B,Q,uBAIzC,SAAU1G,GAKR,MAAO,CACLqC,KAAM,SACNrB,OAAO,EACPc,KAAM9B,EAAKsG,iBAPA,CACX,MAAS,YAM4B,Q,oBAIzC,SAAOtG,GACL,MAAO,CACL2G,YAAa,6CACbtE,KAAM,MACNrB,OAAO,EACPyB,GAAI,CAAC,CACDmE,OAAQ,kDACRtD,OAAQ,SAEV,CACEsD,OAAQ,mCACRtD,OAAQ,eAEV,CACEsD,OAAQ,yDACRtD,OAAQ,OACRQ,OAAO,O,wBAMf,SAAW9D,GACT,MAAO,CACL2G,YAAa,0BACbtE,KAAM,UACNrB,OAAO,EACPyB,GAAI,CAAC,CACDmE,OAAQ,eACRtD,OAAQ,uD,qBAMhB,SAAQtD,GACN,MAAO,CACL2G,YAAa,4CACbtE,KAAM,OACNrB,MAAO,KACPyB,GAAI,CAAC,CACHmE,OAAQ,mBACRtD,OAAQ,gCAEV,CACEsD,OAAQ,iBACRtD,OAAQ,yC,wBAKd,SAAWtD,GACT,MAAO,CACL2G,YAAa,sDACbtE,KAAM,UACNrB,OAAO,EACPyB,GAAI,CAAC,CACHmE,OAAQ,CACNxD,OAAQ,OAEVE,OAAQ,0B,qBAKd,SAActD,GAEd,OADiB,IAAIC,MACL4G,WAAW7G,O,KC9JR8G,E,iGAMnB,SAAkB9G,GAGhB,MAAO,CAAC+G,cAFkB/G,EAAKI,KAEW4G,cADhB,O,qBAP5B,SAAchH,GACZ,OAAO,IAAIC,MAAOgH,kBAAkBjH,O,KCDnBkH,G,2GASpB,SAAmBC,EAAYC,EAAcC,EAASC,EAAaC,EAASC,EAAQC,GACnF,IAAIC,EAASF,EAAOG,UAAP,WAAqBF,IAAMrH,KAAK,CAAC+G,IAE9CA,EAAWS,GAAKT,EAAWS,IAAMT,EAAWpD,EAAIoD,EAAWU,MAAQ,EACnEV,EAAWW,GAAKX,EAAWW,IAAMX,EAAWnD,EAAImD,EAAWY,OAAS,EACpEZ,EAAWa,GAAKb,EAAWa,IAAMb,EAAWpD,EAAIoD,EAAWU,MAC3DV,EAAWc,GAAKd,EAAWc,IAAMd,EAAWnD,EAAImD,EAAWY,OAC3DX,EAAaY,GAAKZ,EAAaY,IAAMZ,EAAarD,EAAIqD,EAAaS,MACnET,EAAaa,GAAKb,EAAaa,IAAMb,EAAapD,EAAIoD,EAAaW,OAEnE,IAAIG,EAAcR,EAChB5E,QACAqF,OAAO,OACPC,QAAQ,cAAc,GACtBC,KAAK,KAAMZ,GACXa,MAAM,MAAO,GACbA,MAAM,OAAQ,GAChBJ,EAAYC,OAAO,OAAOC,QAAQ,WAAW,GAC7CF,EAAYC,OAAO,KAAKC,QAAQ,SAAS,GAGzCV,EAAOa,OAAO,YAAYC,KAAK,IAGR,kBAAZnB,EACVK,EACEa,OAAO,YACPE,OACAC,YAAYrB,GAEdK,EAAOa,OAAO,YAAYC,KAAKnB,GAGhC,IAAIsB,EAAcjB,EAAOa,OAAO,UAE5BK,EAAUlB,EAAOe,OACjBZ,EAAQgB,KAAKrC,IAAIoC,EAAQE,YAAa1B,EAAaS,OACnDE,EAASc,KAAKrC,IAAIoC,EAAQG,aAAc3B,EAAaW,QACrDiB,EAAM,EACNC,EAAO,EACPC,EAAQ,SAASC,EAAK3C,EAAKC,GAC9B,OAAOoC,KAAKrC,IAAIqC,KAAKpC,IAAID,EAAK2C,GAAM1C,IAGjC2C,EAAgB,SAASC,GAC5B,IAAIC,EACAC,EACJ,OAAQF,GACP,IAAK,OACJC,EAAWnC,EAAWpD,EAAI8D,EAAQN,EAClCgC,EAAUpC,EAAWW,GAAKC,EAAS,EACnC,MACD,IAAK,QACJuB,EAAWnC,EAAWpD,EAAIoD,EAAWU,MAAQN,EAC7CgC,EAAUpC,EAAWW,GAAKC,EAAS,EACnC,MACD,IAAK,MACJuB,EAAWnC,EAAWS,GAAKC,EAAQ,EACnC0B,EAAUpC,EAAWnD,EAAI+D,EAASR,EAClC,MACD,IAAK,SACJ+B,EAAWnC,EAAWS,GAAKC,EAAQ,EACnC0B,EAAUpC,EAAWc,GAAKV,EAI5B,MAAO,CAAE0B,KAAMK,EAAUN,IAAKO,IA+D3BC,EA9CiC,WACpC,IAEIC,EADAC,EAAsB,GAG1B,OAAQpC,GACP,IAAK,OACJmC,EAAwB,CAAC,OAAQ,QAAS,MAAO,UACjD,MACD,IAAK,QACJA,EAAwB,CAAC,QAAS,OAAQ,MAAO,UACjD,MACD,IAAK,MACJA,EAAwB,CAAC,MAAO,SAAU,OAAQ,SAClD,MACD,IAAK,SACJA,EAAwB,CAAC,SAAU,MAAO,OAAQ,SAwBpD,OApBaL,EAAc,QACZH,KAAO7B,EAAarD,GAClC2F,EAAoBC,KAAK,QAGbP,EAAc,SACZH,KAAOpB,EAAQT,EAAaY,IAC1C0B,EAAoBC,KAAK,SAGbP,EAAc,OACZJ,IAAM5B,EAAapD,GACjC0F,EAAoBC,KAAK,OAGbP,EAAc,UACZJ,IAAMjB,EAASX,EAAaa,IAC1CyB,EAAoBC,KAAK,UAGnBF,EAAsBG,QAAO,SAAStJ,GAC5C,OAAOoJ,EAAoBG,QAAQvJ,GAAM,KACvC,GAIwBwJ,GAGxBN,IACHlC,EAAckC,GAIf,IAAIO,EAAaX,EAAc9B,GAC/B2B,EAAOc,EAAWd,KAClBD,EAAMe,EAAWf,IAEG,SAAhB1B,GAA0C,UAAhBA,GAvEzB0B,EAAM5B,EAAapD,IAAGgF,EAAM5B,EAAapD,GACzCgF,EAAMjB,EAASX,EAAaa,KAAIe,EAAM5B,EAAaa,GAAKF,GAC5DY,EAAYL,MAAM,MAAOY,EAAM/B,EAAWW,GAAKkB,EAAM,EAAG,EAAGjB,EAAS,IAAM,MAC1EY,EAAYL,MAAM,OAAQ,QAItBW,EAAO7B,EAAarD,IAAGkF,EAAO7B,EAAarD,GAC3CkF,EAAOpB,EAAQT,EAAaY,KAAIiB,EAAO7B,EAAaY,GAAKH,GAC7Dc,EAAYL,MAAM,OAAQY,EAAM/B,EAAWS,GAAKqB,EAAO,EAAG,EAAGpB,EAAQ,IAAM,MAC3Ec,EAAYL,MAAM,MAAO,OAmE1BZ,EAAOU,QAAQ,8BAA8B,GAAOA,QAAQd,GAAa,GAEzEY,EAAYI,MAAM,MAAOU,EAAM,MAAMV,MAAM,OAAQW,EAAO,MAE1DvB,EAAOY,MAAM,MAAOU,EAAM,MAAMV,MAAM,OAAQW,EAAO,Q,2BAGtD,SAAqBzB,EAAQC,GAC5BD,EAAOG,UAAP,WAAqBF,IAAMW,QAAQ,QAAQ,O,MCzJxB4B,E,0GAEpB,SAA6BC,EAAMvF,GAA2B,IAAlBwF,EAAiB,uDAAJ,GAElDC,EAAYF,EAAKG,mBAAmB,eAAxBH,GAChBE,EAAUzF,GAAWwF,EAEvBD,EAAKG,mBAAmB,gBAAgB,kBAAMD,O,uCAG9C,SAAiCF,GACjCA,EAAKG,mBAAmB,gBAAgB,WAEvC,MAAO,MAGRH,EAAKG,mBAAmB,gBAAgB,SAAA1F,GAGvC,OAFqBuF,EAAKG,mBAAmB,eAC3BC,GACD3F,MAGhBuF,EAAKG,mBAAmB,qBAAqB,SAAC3B,EAAM6B,EAAMC,GAGxD,IAFA,IACMC,EAAWD,EAAUE,kBAAkBhC,EAAM8B,EAAUpG,MAD3C,EAC6DoG,GACtEG,EAAI,EAAGA,EAAIF,EAASG,SAAUD,EACrC,GAAIJ,EAAKM,OAAOC,MAAMxI,OAASmI,EAASE,GAAGE,OAAOC,MAAMxI,MAAQiI,EAAKQ,OAAOD,MAAMxI,OAASmI,EAASE,GAAGI,OAAOD,MAAMxI,KAClH,OAAOkI,EAAUQ,aAAaL,GAIlC,MAAO,UAGTT,EAAKG,mBAAmB,aAAa,SAAC3B,EAAM6B,EAAMC,GAGhD,IAFA,IACMC,EAAWD,EAAUE,kBAAkBhC,EAAM8B,EAAUpG,MAD3C,EAC6DoG,GACtEG,EAAI,EAAGA,EAAIF,EAASG,SAAUD,EACrC,GAAIJ,EAAKM,OAAOC,MAAMxI,OAASmI,EAASE,GAAGE,OAAOC,MAAMxI,MAAQiI,EAAKQ,OAAOD,MAAMxI,OAASmI,EAASE,GAAGI,OAAOD,MAAMxI,KAClH,OAAO,EAIX,OAAO,KAGT4H,EAAKG,mBAAmB,qBAAqB,SAAAY,GAI3C,IAHA,IACIC,EAAiBC,SAASF,GAC1BtH,EAAa,EACVuH,EAAiB,KACtBA,GAAkB,MAChBvH,EAGJ,OAAOmF,KAAKsC,MAAMF,GARI,CAAC,GAAI,IAAK,IAAK,KAQavH,MAGpDuG,EAAKG,mBAAmB,cAAc,SAACpJ,GACrC,OAAO,Y,KC9DEoK,EARO,qBAAX1K,OACFA,OAAO0K,GAEP,GCGYC,E,WACnB,WAAYrL,GAAO,oBACjBC,KAAKD,KAAOA,E,gDAGd,SAAasL,GACX,OAAOA,EAAKC,OAAOC,GAAKF,EAAKC,OAAOE,K,2BAGtC,SAAcH,GACZ,OAAOA,EAAKC,OAAOG,GAAKJ,EAAKC,OAAOI,K,mBAGtC,SAAML,GACJ,OAAQrL,KAAK2L,aAAaN,GAAQ,EAAKA,EAAKC,OAAOE,K,mBAGrD,SAAMH,GACJ,OAAQrL,KAAK4L,cAAcP,GAAQ,EAAKA,EAAKC,OAAOI,K,6BAQtD,SAAgBG,EAAOC,GAErB,IAAMnE,EAAK3H,KAAK2F,MAAMmG,GAChBjE,EAAK7H,KAAK4F,MAAMkG,GAClB9H,EAAS2D,EAAKmE,EAAeR,OAAOE,GAIxC,GAHAxH,EAAS4E,KAAKsC,MAAe,IAATlH,GAAgB,IAG/B6H,EAAME,SAAWD,EAAejE,IAAQgE,EAAMG,OAASF,EAAeR,OAAOE,IACrCK,EAAMG,OAASF,EAAeR,OAAOC,GAChF,OAAO,EAIT,GAAKM,EAAMG,SAAWF,EAAenE,IAAQkE,EAAME,OAASD,EAAeR,OAAOW,IACrCJ,EAAME,OAASD,EAAeR,OAAOW,GAChF,OAAO,EAYT,OAAQjI,EADc,IANpB4E,KAAKsD,KAAKtD,KAAKuD,IAAIvD,KAAKwD,IAAIP,EAAMG,OAASrE,GAAK,GAAKiB,KAAKuD,IAAIvD,KAAKwD,IAAIP,EAAME,OAASlE,GAAK,M,kBAUhG,SAAKwE,EAASR,EAAOR,EAAMtK,GAC1B,GAAKsK,EAAL,CAKE,IAAIiB,GAAiB,EACE,cAAnBjB,EAAKkB,KAAKnK,OACZkK,EAAiBtM,KAAK8L,gBAAkB9L,KAAK8L,eAAelB,MAAMxI,OAASiJ,EAAKT,MAAMA,MAAMxI,KAC5FiJ,EAAOA,EAAKT,OAId,IAAM4B,EAAYH,EAAQI,IAG5B,GAAIZ,GAA4B,aAAnBA,EAAMa,UAIf,IAHwB1M,KAAK2M,gBAAgBd,EAAO7L,KAAK8L,gBAGnC,CAEpB9L,KAAK8L,eAAiB,KAEtB9L,KAAK4M,gBAAkBC,YAAW,WAChC5F,EAAW6F,cAAc3B,EAAG7C,OAAOkE,GAAY,kBAJjC,WAWtB,GAAInB,IAASrL,KAAK8L,iBAAkBQ,EAApC,CAGCtM,KAAK8L,eAAiBT,EAIrB,IACMjE,EACJpH,KAAKD,KAAKgN,mBAAmB,CAAE5M,KAAMkL,EAAKT,OAAS,CAAC1G,MAAOlE,KAAKD,KAAKyK,kBAAkBa,EAAKT,MAAO5K,KAAKD,KAAKmE,MAFrF,EAE+GlE,KAAKD,OAAQC,KAAKD,KAAK+K,cAG5JhH,EAAIuH,EAAKC,OAAOE,GAAKxL,KAAKD,KAAKuH,QAAQ0B,KACvCjF,EAAIsH,EAAKC,OAAOI,GAAK1L,KAAKD,KAAKuH,QAAQyB,IACvCnB,EAAQ5H,KAAK2L,aAAaN,GAC1BvD,EAAS9H,KAAK4L,cAAcP,GAKhC2B,aAAahN,KAAK4M,iBAElB,IAAM1F,EAAa,CACjBpD,IACA8D,QACA7D,IACA+D,UAGIX,EAAe,CACnBpD,EAAG,EACHD,EAAG,EACHgE,OAAQ0E,EAAU1D,aAClBlB,MAAO4E,EAAU3D,aAUnB,IACE5B,EAAWgG,YACT/F,EACAC,EACAC,EACA,OACA,GACA+D,EAAG7C,OAAOkE,GACV,gBAEF,MAAMU,GACNjG,EAAWgG,YACT/F,EACAC,EACAC,EACA,OACA,GACA+D,EAAG7C,OAAOkE,GACV,uB,KT3HR,SAASW,EAA8BC,GAAW,IAAD,EAChD,iBAAOC,iBAAiBC,SAASC,MAC/BC,iBAAiBJ,UADnB,aAAO,EAEJK,O,MUtBwBhN,OAApBuJ,E,EAAAA,KAAM0D,E,EAAAA,UAEdC,EAAiCC,0BAA0B5D,G,IA0CtC6D,E,iMACnB,WAAW9N,GAAX,SAAAG,EAAA,kIACiBH,GADjB,cAEKC,KAAKyE,UACTzE,KAAKyE,QAAUqJ,IAAKC,UAHrB,SAMM/N,KAAKgO,WAAWjO,GANtB,gD,sHASA,WAAiBA,GAAjB,qCAAAG,EAAA,yDAEM+N,EAAkBH,IAAKC,SAC7B/N,KAAKkO,qBAAqB,CAAEC,mBAAoBF,IAGhDjO,KAAKoO,UAELpO,KAAKD,KAAOA,EAGPC,KAAKqO,SAAStO,GAXnB,qDAeIuO,EAAWtO,KAAKK,GAAGkO,cAAc,qBAEpCD,EAASE,UAIJC,EAAgBnB,SAASoB,cAAc,QAC/BC,UAAUC,IAAI,mBAExB5O,KAAK6O,uBAAuB9O,GAxBhC,wBAyBCA,EAAK+O,iBAAiBL,GACtBzO,KAAKK,GAAGoI,YAAYgG,GA1BrB,UA6BOM,gBAAM,KA7Bb,gCA+BC/O,KAAKK,GAAGoI,YAAYgG,GA/BrB,eAoCMO,EApCN,2BAqCIjP,GArCJ,IAsCC+H,OAAQ9H,KAAKK,GAAG4O,aAChBrH,MAAO5H,KAAKK,GAAG6O,YACf5H,QAAStH,KAAKsH,QACd7C,QAASzE,KAAKyE,UAzCf,EA6CyC0K,EAA2BvN,OAAOoN,GAAnElI,EA7CR,EA6CQA,cAAeC,EA7CvB,EA6CuBA,cACvB5F,OAAOC,OAAO4N,EAAd7N,OAAA,IAAAA,CAAA,CAA8B2F,iBAAkBC,IAG1CqI,EAAuB,IAAIhE,EAAqB4D,GACpDA,EAAa9K,MAA+C,cAAvC8K,EAAalI,cAAc,GAAG1E,KAAuB4M,EAAalI,cAAc,GAAGnE,OAASqM,EAAalI,cAAc,GAAGnE,OAC3I0M,EAAkBD,EAAqBE,KAAKzN,KAAKuN,GAGvDzB,EAAiC4B,sBAAsBvF,EAAMhK,KAAKyE,QAASuK,GAGrEQ,EAAWxP,KAAKyP,eAAeT,GAE7BU,EAAY,CAACxM,QAASmM,GA3D9B,UAgEuB3B,EAAUe,EAAee,EAAUE,GAhE1D,QAgEMC,EAhEN,OAoEI3P,KAAK4P,kBAAkB3B,IAC1B0B,EAASE,KAAKC,WACdH,EAASE,KAAKrD,YAAYgC,UAEvBxO,KAAK2P,SAAWA,EAxEpB,iD,2FA4ED,SAAuB5P,GAOpB,OAAO,I,kCAMV,YAA8C,IAAvBoO,EAAsB,EAAtBA,mBACtBnO,KAAK+P,aAAe5B,I,+BAGrB,SAAkB6B,GACjB,OAAOA,IAAahQ,KAAK+P,e,qBAG1B,WACK/P,KAAK2P,WACR3P,KAAK2P,SAASE,KAAKC,WACnB9P,KAAK2P,SAASE,KAAKrD,YAAYgC,Y,4BAuBjC,SAAezO,GAgBd,MAfa,CACTkQ,QAAS,6CAEZC,SAAU,CAAE7N,KAAM,MAAO8N,SAAU,WACnC7I,QAASvH,EAAKuH,QACd8I,YVhMEvQ,IAKJA,EAAY,CACXwQ,aAAa,4CACbC,eAAgB,UAChBC,cAAe,UACfC,mBAAoB,WAIF,qBAAX/P,QACoB,qBAApBA,OAAO6M,UACkB,qBAAzB7M,OAAO6M,SAASC,MACK,qBAArBF,mBAGPxN,EAAUwQ,aAAV,UAA4BlD,EAA8B,cAA1D,aAA4EtN,EAAUwQ,cACtFxQ,EAAUyQ,eAAiBnD,EAA8B,yBACzDtN,EAAU0Q,cAAgBpD,EAA8B,wBACxDtN,EAAU2Q,mBAAqBrD,EAA8B,gBAGvDtN,IUuKsB2Q,mBAC3B5I,MAAO7H,EAAK6H,MACZE,OAAQ/H,EAAK+H,OACb3H,KAAMJ,EAAK+G,cACX2J,QAAS/K,EAAqBqI,OAAOhO,GACrC2Q,MAAO5O,EAAmBiM,OAAOhO,GACjC4Q,OAAQzL,EAAoB6I,OAAOhO,GAChC6Q,OAAQ,M,mBAMb,WAEG,MAAO,CAAE5H,KAAM,EAAGD,IAAK,EAAG8H,MAAO,EAAGC,OAAQ,O,GA1JLhR,GA6N3CiR,IAAaC,cAAcnD","file":"static/js/3.0f4b8b59.chunk.js","sourcesContent":["export default {};\n\nlet CONSTANTS;\n\n// IMPORTANT NOTE: You can't call this until a chart is being rendered. Otherwise it will not give the body time to get the properties.\nexport function getConstants() {\n\tif (CONSTANTS) {\n\t\treturn CONSTANTS;\n\t}\n\tlet preferredFonts;\n\n\tCONSTANTS = {\n\t\tfontFamilies: `adobe-clean, Helvetica, Arial, sans-serif`,\n\t\taxisLabelColor: '#b2b2b2',\n\t\taxisGridColor: '#ebebeb',\n\t\tvizBackgroundColor: '#ffffff',\n\t};\n\n\tif (\n\t\ttypeof window !== 'undefined' &&\n\t\ttypeof window.document !== 'undefined' &&\n\t\ttypeof window.document.body !== 'undefined' &&\n\t\ttypeof getComputedStyle !== 'undefined'\n\t) {\n\t\t// returns a string similar to: \" adobe-clean, \"Noto Sans JP\", \"Noto Sans SC\", \"Noto Sans TC\", \"Noto Sans KR\"\n\t\tCONSTANTS.fontFamilies = `${getComputedStylePropertyValue('--aa-fonts')}, ${CONSTANTS.fontFamilies}`;\n\t\tCONSTANTS.axisLabelColor = getComputedStylePropertyValue('--aa-axis-label-color');\n\t\tCONSTANTS.axisGridColor = getComputedStylePropertyValue('--aa-axis-grid-color');\n\t\tCONSTANTS.vizBackgroundColor = getComputedStylePropertyValue('--aa-viz-bg');\n\t}\n\n\treturn CONSTANTS;\n}\n\nfunction getComputedStylePropertyValue(property) {\n\treturn getComputedStyle(document.body)\n\t\t.getPropertyValue(property)\n\t\t?.trim();\n}\n","// Keep import below.\n// import { _, MetricFormatter } from '@analytics/core';\nimport { _, MetricFormatter } from './../analytics/core';\n\n// Params:\n// numberFormatter(number, {type:int* | time | percent | currency , precision:0 , abbreviate: false})\n\nexport default class VegaViz {\n  // Call this._setOpts\n\tconstructor(opts = {}) {\n\t\tthis._setOpts(opts);\n\t}\n\n\tasync draw(opts = {}) {\n    // Call this._setOpts\n\t\tthis._setOpts(opts);\n\t}\n\n  // If data is null, return false. If this is a unit test, return false.\n\tvalidate(data) {\n\t\tif (!data) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.isUnitTest) {\n\t\t\tthis.el.innerHTML = JSON.stringify(data, null, 2);\n\t\t\treturn false; // For now we always return false if it is a unit test so we don't try to render via cloudviz.\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tget isUnitTest() {\n\t\treturn !!window.isUnitTest;\n\t}\n\n\t// Calls update with the same opts previously used. Used for resizing.\n\trefresh() {\n\t\t// VegaVizComponent currently takes care of resizing via React's lifecycle methods\n\t\t// this.update(this._opts);\n\t}\n\n\tonResize() {\n\t\tthis.refresh();\n\t}\n\n\tdestroy() {\n\t\t// cleanup.\n\t}\n\n\t_callOptsHandler(method, args) {\n\t\tif (!this._opts[method]) {\n\t\t\treturn;\n\t\t}\n\t\treturn this._opts[method].apply(null, args);\n\t}\n\n\tformatNumber(value, options = {}, optionOverrides = null) {\n\t\treturn this._numberFormatter(value, optionOverrides ? Object.assign({}, options, optionOverrides) : options);\n\t}\n\n\tonMouseOver(...args) {\n\t\treturn this._callOptsHandler('onMouseOver', args);\n\t}\n\n\tonMouseOut(...args) {\n\t\treturn this._callOptsHandler('onMouseOut', args);\n\t}\n\n\tonContextMenu(...args) {\n\t\treturn this._callOptsHandler('onContextMenu', args);\n\t}\n\n\tonRender(...args) {\n\t\treturn this._callOptsHandler('onRender', args);\n\t}\n\n\thighlightDataByIds(ids) {\n\t\t/* implemented in subclass */\n\t}\n\n\tunhighlightData() {\n\t\t/* implemented in subclass */\n\t}\n\n\tonError(...args) {\n\t\tif (this.el && !this.isUnitTest) {\n\t\t\tthis.el.innerHTML = '';\n\t\t}\n\t\treturn this._callOptsHandler('onError', args);\n\t}\n\n\tget locale() {\n\t\treturn this._opts.locale || 'en-US';\n\t}\n\n\tget l10nConfig() {\n\t\treturn this._opts.l10n || {};\n\t}\n\n\t/*\n\t * opts should have a data property defined like:\n\t * opts = {\n\t * \tdata: {\n\t * \t\tdata: [value, value, value]\n\t * \t}\n\t * }\n\t *\n\t * or\n\t * opts = {\n\t * \ty: [value, value, value],\n\t * \tx: [value, value, value]\n\t * }\n\t */\n\t// AN-232139 - Don't call this outside of VegaViz, there are other opts that get injected in VegaVizComponent\n\t_setOpts(opts = {}) {\n    // Element passed into the class.\n    this.el = opts.el;\n\n    // assign the number formatter passed into the function, or\n    // create a new MetricFormatter() otherwise.\n\t\tif (opts.numberFormatter) {\n\t\t\tthis._numberFormatter = opts.numberFormatter;\n\t\t} else if (!this._numberFormatter) {\n\t\t\tlet metricFormatter = new MetricFormatter();\n\t\t\tthis._numberFormatter = metricFormatter.format.bind(metricFormatter);\n\t\t}\n\t\tthis._opts = opts;\n\t}\n}\n","// Keep the import below.\n// import { _ } from '@analytics/core';\nimport { _ } from './../../analytics/core';\n\nexport default class ForceDirectedMarks {\n  getMarks(opts) {\n\t\tconst marks = _.compact([\n    this.getNodeMarks(opts), \n    this.getNodeTextMarks(opts), \n    this.getLinkMarks(opts)\n  ]);\n\n\t\treturn marks;\n  }\n  \n  getNodeMarks(opts) {\n    return {\n      name: \"nodes\",\n      type: \"symbol\",\n      zindex: 1,\n      from: {\n        data: \"node-data\"\n      },\n      on: [{\n          trigger: \"fix\",\n          modify: \"node\",\n          values: \"fix === true ? {fx: node.x, fy: node.y} : {fx: fix[0], fy: fix[1]}\"\n        },\n        {\n          trigger: \"!fix\",\n          modify: \"node\",\n          values: \"{fx: null, fy: null}\"\n        }\n      ],\n      encode: {\n        enter: {\n          fill: {\n            scale: \"color\",\n            field: \"group\"\n          },\n          stroke: {\n            value: \"black\"\n          },\n          tooltip: {\n            signal: \"{Name: datum.name, Value: format(datum.volume, ',')}\"\n          },\n          size: {\n            scale: \"size\", \n            field: \"normalizeVolume\"\n          }\n        },\n        update: {\n          // size: {\n          //   signal: \"datum.volume ? datum.volume / 100 * nodeRadius / 10 : nodeRadius * nodeRadius * 2\"\n          // },\n          cursor: {\n            value: \"pointer\"\n          }\n        }\n      },\n\n      transform: [this.getForceTransform(opts)]\n    }; \n  }\n\n  getForceTransform(opts) {\n    return {\n      type: \"force\",\n      iterations: 300,\n      restart: {\n        signal: \"restart\"\n      },\n      static: {\n        signal: \"static\"\n      },\n      signal: \"force\",\n      forces: [{\n          force: \"center\",\n          x: {\n            signal: \"cx\"\n          },\n          y: {\n            signal: \"cy\"\n          }\n        },\n        {\n          force: \"collide\",\n          radius: {\n            signal: \"nodeRadius\"\n          }\n        },\n        {\n          force: \"nbody\",\n          strength: {\n            signal: \"nodeCharge\"\n          }\n        },\n        {\n          force: \"link\",\n          links: \"link-data\",\n          distance: {\n            signal: \"linkDistance\"\n          }\n        }\n      ]\n    }\n  }\n\n  getNodeTextMarks(opts) {\n    return {\n      type: \"text\",\n      name: \"node-text\",\n      from: {data: \"nodes\"},\n      zindex: 2,\n      encode: {\n        enter: {\n          align: {value: \"center\"},\n          baseline: {value: \"middle\"},\n          fontSize: {value: 12}, \n          fill: {value: \"black\"}\n        },\n        update: {\n          text: {signal: \"[substring(datum.datum.name, 0, floor(nodeRadius / 2.5)), getAdjustedVolume(datum.datum.volume)]\"},\n          x: {signal: \"datum.x\"},\n          y: {signal: \"datum.y\"},\n          tooltip: {\n            signal: \"{Name: datum.datum.name, Value: format(datum.datum.volume, ',')}\"\n          },\n          cursor: {\n            value: \"pointer\"\n          }\n        }\n      }\n    }\n  }\n\n  getLinkMarks(opts) {\n    return {\n      type: \"path\",\n      from: {\n        data: \"link-data\"\n      },\n      interactive: false,\n      encode: {\n        update: {\n          stroke: {\n            signal: `node ? getHighlightColor(node, datum, getChartOpts('${opts.chartID}')) : \"#ccc\"`\n          },\n          strokeWidth: {\n            field: \"normalizeValue\"\n          },\n          tooltip: {value: \"{left}\"},\n          zindex: {signal: `node ? getZIndex(node, datum, getChartOpts('${opts.chartID}')) : 0`}\n        }\n      },\n      transform: [{\n        type: \"linkpath\",\n        require: {\n          signal: \"force\"\n        },\n        shape: \"curve\",\n        sourceX: \"datum.source.x\",\n        sourceY: \"datum.source.y\",\n        targetX: \"datum.target.x\",\n        targetY: \"datum.target.y\"\n      }]\n    }\n  }\n\n  static create(opts) {\n\t\tconst instance = new this();\n\t\treturn instance.getMarks(opts);\n\t}\n}\n","// Keep the import below.\n// import { _ } from '@analytics/core';\nimport { _ } from './../../analytics/core';\n\nexport default class ForceDirectedScales {\n  getScales(opts) {\n\t\treturn _.compact([\n      this.getColorScales(opts),\n      this.getVolumeScale(opts)\n    ]);\n  }\n  \n  getColorScales(opts) {\n    return {\n      name: \"color\",\n      type: \"ordinal\",\n      domain: {\n        data: \"node-data\",\n        field: \"group\"\n      },\n      range: {\n        scheme: \"category20c\"\n      }\n    }\n  }\n\n  getVolumeScale(opts) {\n    return {\n      name: \"size\",\n      domain: {data: \"node-data\", field: \"normalizeVolume\"},\n      zero: false,\n      range: [200, 1000]\n    }\n  }\n\n  static create(opts) {\n\t\tconst instance = new this();\n\t\treturn instance.getScales(opts);\n\t}\n}","// Keep the import below.\n// import { _ } from '@analytics/core';\nimport { _ } from './../../analytics/core';\n\nexport default class ForceDirectedSignals { \n  getSignals(opts) {\n    return _.compact([\n      this.getCx(opts),\n      this.getCy(opts),\n      this.getNodeRadius(opts),\n      this.getNodeCharge(opts),\n      this.getLinkDistance(opts),\n      this.getStatic(opts),\n      this.getFix(opts), \n      this.getClicked(opts),\n      this.getNode(opts),\n      this.getRestart(opts)\n    ]); \n  }\n\n  getCx(opts) {\n    return {\n      name: \"cx\",\n      update: \"width / 2\"\n    }; \n  }\n\n  getCy(opts) {\n    return {\n      name: \"cy\",\n      update: \"height / 2\"\n    }; \n  }\n\n  getNodeRadius(opts) {\n    const bind = {\n      input: \"range\",\n      min: 30,\n      max: 75,\n      step: 1\n    }; \n\n    return {\n      name: \"nodeRadius\",\n      value: 20,\n      bind: opts.allowSignalBinds ? bind : null\n    }; \n  }\n\n  getNodeCharge(opts) {\n    const bind = {\n        input: \"range\",\n        min: -100,\n        max: 10,\n        step: 1\n      }\n\n    return {\n      name: \"nodeCharge\",\n      value: -30,\n      bind: opts.allowSignalBinds ? bind : null\n    }; \n  }\n\n  getLinkDistance(opts) {\n    const bind = {\n      input: \"range\",\n      min: 5,\n      max: 100,\n      step: 1\n    }\n\n    return {\n      name: \"linkDistance\",\n      value: 30,\n      bind: opts.allowSignalBinds ? bind : null\n    }; \n  }\n\n  getStatic(opts) {\n    const bind = {\n      \"input\": \"checkbox\"\n    }\n    \n    return {\n      name: \"static\",\n      value: true,\n      bind: opts.allowSignalBinds ? bind : null\n    }\n  }\n\n  getFix(opts) {\n    return {\n      description: \"State variable for active node fix status.\",\n      name: \"fix\",\n      value: false,\n      on: [{\n          events: \"symbol:mouseout[!event.buttons], window:mouseup\",\n          update: \"false\"\n        },\n        {\n          events: \"symbol:mouseover, text:mouseover\",\n          update: \"fix || true\"\n        },\n        {\n          events: \"[symbol:mousedown, window:mouseup] > window:mousemove!\",\n          update: \"xy()\",\n          force: true\n        }\n      ]\n    };\n  }\n\n  getClicked(opts) {\n    return {\n      description: \"Clicked an active node.\",\n      name: \"clicked\",\n      value: false,\n      on: [{\n          events: \"symbol:click\",\n          update: \"datum.name == 'Other Pages' ? loadMore() : null\"\n        }\n      ]\n    };\n  }\n\n  getNode(opts) {\n    return {\n      description: \"Graph node most recently interacted with.\",\n      name: \"node\",\n      value: null,\n      on: [{\n        events: \"symbol:mouseover\",\n        update: \"fix === true ? item() : node\"\n      },\n      {\n        events: \"text:mouseover\",\n        update: \"fix === true ? datum.datum : node\"\n      }]\n    };\n  }\n\n  getRestart(opts) {\n    return {\n      description: \"Flag to restart Force simulation upon data changes.\",\n      name: \"restart\",\n      value: false,\n      on: [{\n        events: {\n          signal: \"fix\"\n        },\n        update: \"fix && fix.length\"\n      }]\n    };\n  }\n\n  static create(opts) {\n\t\tconst instance = new this();\n\t\treturn instance.getSignals(opts);\n\t}\n}\n","export default class ForceDirectedVegaDataFormatter {\n  static format(opts) {\n    return new this().formatDataForVega(opts); \n  }\n\n  // TODO: Implement at a later time. \n  formatDataForVega(opts) { \n    const fakeFormattedData = opts.data; \n    const fakeAggregateData = {}; \n    return {formattedData: fakeFormattedData, aggregateData: fakeAggregateData}; \n  }\n}\n","/* eslint-disable no-mixed-operators */\nexport default class VizTooltip {\n\t/**\n\t * Shows a tooltip at a given position with HTML content.\n\t * @param targetRect - The bounding rect of the SVG element we are pointing the tooltip to. Has properties: x, y, width, height.\n\t * @param boundaryRect - The bounding rect which the tooltip can not be displayed outside. If the tooltip gets too close to a boundary, it will try to flip to a different orientation.  Has properties: x, y, width, height.\n\t * @param content - The HTML content displayed in the tooltip. Accepts an HTML string or assumes the input to be a DOM node if it's not a string.\n\t * @param padding - The amount of padding we want to add to push the tooltip out further\n\t * @param parent - The parent the tooltip will be attached to\n\t */\n\tstatic showTooltip(targetRect, boundaryRect, content, orientation, padding, parent, id) {\n\t\tlet tipDiv = parent.selectAll(`#${id}`).data([targetRect]); \n\n\t\ttargetRect.cx = targetRect.cx || targetRect.x + targetRect.width / 2;\n\t\ttargetRect.cy = targetRect.cy || targetRect.y + targetRect.height / 2;\n\t\ttargetRect.dx = targetRect.dx || targetRect.x + targetRect.width;\n\t\ttargetRect.dy = targetRect.dy || targetRect.y + targetRect.height;\n\t\tboundaryRect.dx = boundaryRect.dx || boundaryRect.x + boundaryRect.width;\n\t\tboundaryRect.dy = boundaryRect.dy || boundaryRect.y + boundaryRect.height;\n\n\t\tlet tipDivEnter = tipDiv\n\t\t\t.enter()\n\t\t\t.append('div')\n\t\t\t.classed('dv-tooltip', true)\n\t\t\t.attr('id', id)\n\t\t\t.style('top', 0)\n\t\t\t.style('left', 0);\n\t\ttipDivEnter.append('div').classed('content', true);\n\t\ttipDivEnter.append('b').classed('notch', true);\n\n\t\t// First clear out the content\n\t\ttipDiv.select('.content').html('');\n\n\t\t// Assume the content to be a DOM node if it's not a string\n\t\tif (typeof content !== 'string') {\n\t\t\ttipDiv\n\t\t\t\t.select('.content')\n\t\t\t\t.node()\n\t\t\t\t.appendChild(content);\n\t\t} else {\n\t\t\ttipDiv.select('.content').html(content);\n\t\t}\n\n\t\tlet tipDivNotch = tipDiv.select('.notch');\n\n\t\tlet tipNode = tipDiv.node();\n\t\tlet width = Math.min(tipNode.offsetWidth, boundaryRect.width);\n\t\tlet height = Math.min(tipNode.offsetHeight, boundaryRect.height);\n\t\tlet top = 0;\n\t\tlet left = 0;\n\t\tlet clamp = function(val, min, max) {\n\t\t\treturn Math.min(Math.max(min, val), max);\n\t\t};\n\n\t\tlet setTopAndLeft = function(_orientation) {\n\t\t\tlet tempLeft;\n\t\t\tlet tempTop;\n\t\t\tswitch (_orientation) {\n\t\t\t\tcase 'left':\n\t\t\t\t\ttempLeft = targetRect.x - width - padding;\n\t\t\t\t\ttempTop = targetRect.cy - height / 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'right':\n\t\t\t\t\ttempLeft = targetRect.x + targetRect.width + padding;\n\t\t\t\t\ttempTop = targetRect.cy - height / 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'top':\n\t\t\t\t\ttempLeft = targetRect.cx - width / 2;\n\t\t\t\t\ttempTop = targetRect.y - height - padding;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'bottom':\n\t\t\t\t\ttempLeft = targetRect.cx - width / 2;\n\t\t\t\t\ttempTop = targetRect.dy + padding;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\treturn { left: tempLeft, top: tempTop };\n\t\t};\n\n\t\tlet snapVertical = function() {\n\t\t\tif (top < boundaryRect.y) top = boundaryRect.y; // snap to the top\n\t\t\tif (top + height > boundaryRect.dy) top = boundaryRect.dy - height; // snap to the bottom\n\t\t\ttipDivNotch.style('top', clamp(targetRect.cy - top - 5, 3, height - 13) + 'px');\n\t\t\ttipDivNotch.style('left', null);\n\t\t};\n\n\t\tlet snapHorizontal = function() {\n\t\t\tif (left < boundaryRect.x) left = boundaryRect.x; // snap to the left\n\t\t\tif (left + width > boundaryRect.dx) left = boundaryRect.dx - width; // snap to the right\n\t\t\ttipDivNotch.style('left', clamp(targetRect.cx - left - 5, 3, width - 13) + 'px');\n\t\t\ttipDivNotch.style('top', null);\n\t\t};\n\n\t\tlet determineNextViableOrientation = function() {\n\t\t\tlet dimensions;\n\t\t\tlet invalidOrientations = [];\n\t\t\tlet orientationPreference;\n\n\t\t\tswitch (orientation) {\n\t\t\t\tcase 'left':\n\t\t\t\t\torientationPreference = ['left', 'right', 'top', 'bottom'];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'right':\n\t\t\t\t\torientationPreference = ['right', 'left', 'top', 'bottom'];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'top':\n\t\t\t\t\torientationPreference = ['top', 'bottom', 'left', 'right'];\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'bottom':\n\t\t\t\t\torientationPreference = ['bottom', 'top', 'left', 'right'];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdimensions = setTopAndLeft('left');\n\t\t\tif (dimensions.left < boundaryRect.x) {\n\t\t\t\tinvalidOrientations.push('left');\n\t\t\t}\n\n\t\t\tdimensions = setTopAndLeft('right');\n\t\t\tif (dimensions.left + width > boundaryRect.dx) {\n\t\t\t\tinvalidOrientations.push('right');\n\t\t\t}\n\n\t\t\tdimensions = setTopAndLeft('top');\n\t\t\tif (dimensions.top < boundaryRect.y) {\n\t\t\t\tinvalidOrientations.push('top');\n\t\t\t}\n\n\t\t\tdimensions = setTopAndLeft('bottom');\n\t\t\tif (dimensions.top + height > boundaryRect.dy) {\n\t\t\t\tinvalidOrientations.push('bottom');\n\t\t\t}\n\n\t\t\treturn orientationPreference.filter(function(el) {\n\t\t\t\treturn invalidOrientations.indexOf(el) < 0;\n\t\t\t})[0];\n\t\t};\n\n\t\t// Determine where the tooltip can go\n\t\tlet nextViableOrientation = determineNextViableOrientation();\n\n\t\t// If there is a viable orientation, use it. Otherwise, just use whatever the user defined\n\t\tif (nextViableOrientation) {\n\t\t\torientation = nextViableOrientation;\n\t\t}\n\n\t\t// Finalize tooltip dimensions\n\t\tlet dimensions = setTopAndLeft(orientation);\n\t\tleft = dimensions.left;\n\t\ttop = dimensions.top;\n\n\t\tif (orientation === 'left' || orientation === 'right') {\n\t\t\tsnapVertical();\n\t\t} else {\n\t\t\tsnapHorizontal();\n\t\t}\n\n\t\ttipDiv.classed('top right left bottom hide', false).classed(orientation, true);\n\n\t\ttipDivEnter.style('top', top + 'px').style('left', left + 'px');\n\n\t\ttipDiv.style('top', top + 'px').style('left', left + 'px'); \n\t}\n\n\tstatic removeTooltip(parent, id) {\n\t\tparent.selectAll(`#${id}`).classed('hide', true);\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\n// Keep import below. \n//import { d3, isNumeric } from '@analytics/core';\nimport { d3, isNumeric } from './../../analytics/core';\n\nimport VizTooltip from './../VizTooltip';\n\n// Expression Functions\n// Vega allows custom functions that we can use for formatting, additional data processing, etc.\n// See docs: https://vega.github.io/vega/docs/api/extensibility/#expressions\nexport default class LineExpressionFunctions {\n\t//we will add each chart instance to this hash as they are created (when multiple charts are on the page, we need to store opts separately for each one)\n\tstatic registerChartInstance(vega, chartID, chartsOpts = {}) {\n    // Return the matching value in the registry (only one param), or undefined if not found.\n\t\tconst allCharts = vega.expressionFunction('getAllCharts')();\n    allCharts[chartID] = chartsOpts;\n    // R\n\t\tvega.expressionFunction('getAllCharts', () => allCharts);\n\t}\n\n  static registerStaticExpressions(vega) {\n\t\tvega.expressionFunction('getAllCharts', () => {\n\t\t\t//start with an empty object, will get filled as chart instances are created\n\t\t\treturn {};\n\t\t});\n\n\t\tvega.expressionFunction('getChartOpts', chartID => {\n\t\t\tconst getAllCharts = vega.expressionFunction('getAllCharts');\n\t\t\tconst allCharts = getAllCharts();\n\t\t\treturn allCharts[chartID];\n\t\t});\n\n    vega.expressionFunction('getHighlightColor', (node, link, chartOpts) => { \n      const NUM_EDGES = 5; \n      const topEdges = chartOpts.getTopVolumeEdges(node, chartOpts.links, NUM_EDGES, chartOpts); \n      for (let i = 0; i < topEdges.length; ++i) {\n        if (link.source.datum.name === topEdges[i].source.datum.name && link.target.datum.name === topEdges[i].target.datum.name) {\n          return chartOpts.swatchColors[i]; \n        }\n      }\n\n      return \"#ccc\"; \n    });\n\n    vega.expressionFunction('getZIndex', (node, link, chartOpts) => {\n      const NUM_EDGES = 5; \n      const topEdges = chartOpts.getTopVolumeEdges(node, chartOpts.links, NUM_EDGES, chartOpts);    \n      for (let i = 0; i < topEdges.length; ++i) {\n        if (link.source.datum.name === topEdges[i].source.datum.name && link.target.datum.name === topEdges[i].target.datum.name) {\n          return 1; \n        }\n      }\n\n      return 0; \n    });\n\n    vega.expressionFunction('getAdjustedVolume', volume => {\n      const abbreviations = ['', 'k', 'm', 'b']; \n      let adjustedVolume = parseInt(volume); \n      let iterations = 0; \n      while (adjustedVolume > 1000) {\n        adjustedVolume /= 1000; \n        ++iterations; \n      } \n\n      return Math.round(adjustedVolume) + abbreviations[iterations]; \n    });\n\n    vega.expressionFunction('checkValue', (value) => {\n      return null;\n    });\n  }\n}","let d3Lib;\nif (typeof window !== 'undefined') {\n\td3Lib = window.d3;\n} else {\n\td3Lib = {};\n}\n\nconst d3 = d3Lib;\n\nexport default d3;\n","// Keep imports below.\n//import { d3 } from '@analytics/core';\n\nimport d3 from './../../d3.js';\n\nimport VizTooltip from './../VizTooltip';\n\nexport default class ForceDirectedTooltip {\n  constructor(opts) { \n    this.opts = opts;\n\t}\n\n  getItemWidth(item) {\n    return item.bounds.x2 - item.bounds.x1;\n  }\n\n  getItemHeight(item) {\n    return item.bounds.y2 - item.bounds.y1;\n  }\n\n  getCx(item) {\n    return (this.getItemWidth(item) / 2) + item.bounds.x1;\n  }\n\n  getCy(item) {\n    return (this.getItemHeight(item) / 2) + item.bounds.y1; \n  }\n\n  /**\n   * Check if still floating over the previous node. \n   * @param event - A triggered event (usually called on 'mouseout')\n   * @param currentTooltip - The tooltip that is currently rendered (potentially will be removed)\n   */\n  checkIfOverNode(event, currentTooltip) {\n    // TODO: May need to make adjustments if padding is added later on... \n    const cx = this.getCx(currentTooltip); \n    const cy = this.getCy(currentTooltip);  \n    let radius = cx - currentTooltip.bounds.x1; \n    radius = Math.round(radius * 100) / 100; \n\n    // Directly over the center of circle in y-direction\n    if ((event.layerY === currentTooltip.cy) && (event.layerX > currentTooltip.bounds.x1) \n                                             && (event.layerX < currentTooltip.bounds.x2)) {\n      return true; \n    }\n\n    // Directly over the center of circle in x-direction\n    if ((event.layerX === currentTooltip.cx) && (event.layerY > currentTooltip.bounds.xy) \n                                             && (event.layerY < currentTooltip.bounds.xy)) {\n      return true; \n    }\n\n    // Use right triangles to calculate distance \n    const distanceFromCenter = \n      Math.sqrt(Math.pow(Math.abs(event.layerX - cx), 2) + Math.pow(Math.abs(event.layerY - cy), 2));\n\n    // event.layerX and event.layerY are slightly imprecise (values are always integers), \n    // so we subtract a small number below from the radius so the tooltips don't stick \n    // when the mouseout is triggered directly off the edge of the node. This means that \n    // the tooltips disappear slightly early, but prevents tooltips from incorrectly persisting. \n    const RADIUS_OFFSET = 1.5;  \n    return (radius - RADIUS_OFFSET) > distanceFromCenter; \n  }\n\n\tshow(handler, event, item, value) { \n\t\tif (!item) {\n\t\t\treturn;\n\t\t}\n    \n    // Adjust for 'text' mark tooltips. \n    let isEqualTooltip = false; \n    if (item.mark.name === \"node-text\") {\n      isEqualTooltip = this.currentTooltip && this.currentTooltip.datum.name === item.datum.datum.name; \n      item = item.datum; \n    }\n\n    // Note: Slightly different syntax\n    const container = handler._el;\n\n\t\t// when mousing out of a point, remove with a timeout\n\t\tif (event && event.vegaType === 'mouseout') {\n      const isStillOverNode = this.checkIfOverNode(event, this.currentTooltip);\n      //console.log(\"Is still over node:\", isStillOverNode);  \n\n      if (!isStillOverNode) {\n        const timeout = 500;\n        this.currentTooltip = null;\n\n        this.tooltipCancelId = setTimeout(() => {\n          VizTooltip.removeTooltip(d3.select(container), 'node-tooltip');\n        }, timeout);\n      }\n\t\t\treturn;\n\t\t}\n\n\t\t//if we are already over this tooltip don't show again\n\t\tif (item === this.currentTooltip || isEqualTooltip) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tthis.currentTooltip = item;\n\t\t}\n\n    //ADOBE: create formatter to format tooltip information below (see LineTooltip.js for more). \n    const NUM_LINKS_TO_SHOW = 5; \n    const content = \n      this.opts.nodeTooltipContent({ data: item.datum }, {links: this.opts.getTopVolumeEdges(item.datum, this.opts.links, NUM_LINKS_TO_SHOW, this.opts)}, this.opts.swatchColors);\n\n    //calculate the bbox of the point we are hovering over\n    let x = item.bounds.x1 + this.opts.padding.left;\n    let y = item.bounds.y1 + this.opts.padding.top;\n    let width = this.getItemWidth(item);\n    let height = this.getItemHeight(item);\n     \n\t\t//before showing, cancel any existing timeouts\n\t\t//eg if the user moved to another dot before the 'mouseout' timeout is up,\n\t\t//we don't want to remove the tooltip of the next dot\n    clearTimeout(this.tooltipCancelId);\n\n    const targetRect = {\n      x,\n      width,\n      y,\n      height,\n    }; \n\n    const boundaryRect = {\n      y: 0,\n      x: 0,\n      height: container.offsetHeight,\n      width: container.offsetWidth,\n    }; \n\n\t\t//show the tooltip\n    // Note: The code below is a workaround. When the first tooltip displays, \n    // there is no node-tooltip in the DOM, which means the tooltip displays incorrectly\n    // (it displays in the top left corner only with no content information). \n    // This is due to the tipDiv.node() being null in the VizTooltip class. \n    // Catching the error allows the initial tooltip code to run, then immediately \n    // followed by displaying a functioning tooltip. \n    try {\n      VizTooltip.showTooltip(\n        targetRect,\n        boundaryRect,\n        content,\n        'left',\n        10,\n        d3.select(container),\n        'node-tooltip',\n      ); \n    } catch(error) {\n      VizTooltip.showTooltip(\n        targetRect,\n        boundaryRect,\n        content,\n        'left',\n        10,\n        d3.select(container),\n        'node-tooltip',\n      );\n    }\n  } \n}\n","// TODO: Update the below imports using the @analytics syntax.\n// TODO: Remove the .js at the end of the files later on...\nimport { _, MetricFormatter, isNumeric, moment, sleep } from './../../analytics/core';\nimport guid from './../../analytics/guid';\n\nimport ChartFactory from './../ChartFactory';\nimport VegaViz from '../VegaViz';\nimport ForceDirectedMarks from './ForceDirectedMarks';\nimport ForceDirectedScales from './ForceDirectedScales';\nimport ForceDirectedSignals from './ForceDirectedSignals';\nimport ForceDirectedVegaFormatter from './ForceDirectedVegaDataFormatter';\nimport ForceDirectedExpressionFunctions from './ForceDirectedExpressionFunctions'; \nimport ForceDirectedTooltip from './ForceDirectedTooltip';  \nimport { getConstants } from './../VizConstants';\n\nconst { vega, vegaEmbed } = window;\n//register custom functions with vega\nForceDirectedExpressionFunctions.registerStaticExpressions(vega);\n/**\n * Parent class:\n * this.el - the current element storing the view.\n *\n *\n *\n *\n * Class Values:\n *\n * this.chartID - the id of the current chart.\n * this.lastRenderId - the id of the last desired render item.\n * this.vegaView - The current vega view for a Line Graph.\n * this.opts - The opts passed to setupChart. Should have a\n * form of this.opts - {\n *  dataSets: [\n *    data: [\n *      dateGranularity\n *    ]\n *  ],\n *  showLoadingState: function(vegaContainer), - should display a loading indicator on the new vegaContainer element based on the function passed in opts\n *  locale,\n *  shouldRenderSmallChart,\n *\n * }\n *\n *\n * this.setupChart(opts) - async:\n * - 1. assigns a new lastRenderId by calling this.cancelPendingRenders()\n * - 2. calls this.destroy() (class function for removing the previous view)\n * - 3. call this.validate(opts) (function in VegaViz) to make sure opts exists and it is not a unit test\n * - 4. Remove the actual element displayed on the screen: Remove the current .vega-container element shown on the screen.\n * - 5. Create a new div and add it to the 'vega-container' class.\n * - 6. Add the new div to the element (display it), showing a loading indicator if necessary.\n * - 7. Store everything necessary for a chart in a chartOptions object.\n * - 8. Pass the chartOptions to a LineVegaDataFormatter. This function returns formattedData and aggreggate data, which are used to update the chartOptions object.\n * - 9. Create a LineToolTip by passing the updated chartOptions.\n * - 10.\n *\n * this.validate() - returns false if this.dataSets does not exist.\n */\n\nexport default class ForceDirected extends VegaViz {\n  async draw(opts) {\n\t\tawait super.draw(opts);\n\t\tif (!this.chartID) {\n\t\t\tthis.chartID = guid.create();\n\t\t}\n     \n\t\tawait this.setupChart(opts);\n\t}\n\n  async setupChart(opts) {\n\t\t//the vegaEmbed call is async - cancel any previous renders that haven't finished\n\t\tconst currentRenderId = guid.create();\n\t\tthis.cancelPendingRenders({ newPendingRenderId: currentRenderId });\n\n\t\t// Destroy the last vega container so we can measure the appropriate chart dimensions from a clean slate\n\t\tthis.destroy();\n\n\t\tthis.opts = opts;\n\n    // Called in parent class. \n\t\tif (!this.validate(opts)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet existing = this.el.querySelector('.vega-container');\n\t\tif (existing) {\n\t\t\texisting.remove();\n\t\t}\n\n\t\t//create the container\n\t\tconst vegaContainer = document.createElement('div');\n\t\tvegaContainer.classList.add('vega-container');\n\n\t\tif (this.shouldShowLoadingState(opts)) {\n\t\t\topts.showLoadingState(vegaContainer);\n\t\t\tthis.el.appendChild(vegaContainer);\n\t\t\t// set a timeout here to flush the dom changes we just made\n\t\t\t// if we don't, the thread will just keep plowing through and the spinner will never show\n\t\t\tawait sleep(500);\n\t\t} else {\n\t\t\tthis.el.appendChild(vegaContainer);\n\t\t}\n\n    // ADOBE: Handle localization here. \n\n\t\tconst chartOptions = {\n\t\t\t...opts,\n\t\t\theight: this.el.clientHeight,\n\t\t\twidth: this.el.clientWidth,\n\t\t\tpadding: this.padding,\n\t\t\tchartID: this.chartID,\n\t\t};\n\n    //TODO: format the data for vega (right now it simply returns the data passed in). \n\t\tconst { formattedData, aggregateData } = ForceDirectedVegaFormatter.format(chartOptions);\n\t\tObject.assign(chartOptions, { formattedData, ...aggregateData });\n\n\t\t//TODO: create tooltip handler\n\t\tconst forceDirectedTooltip = new ForceDirectedTooltip(chartOptions);\n    chartOptions.links = chartOptions.formattedData[1].name === 'link-data' ? chartOptions.formattedData[1].values : chartOptions.formattedData[0].values; \n\t\tconst tooltipCallback = forceDirectedTooltip.show.bind(forceDirectedTooltip);\n \n\t\t//TODO: create a expression for the instance so we can reference options and custom instance functions inside of vega\n\t\tForceDirectedExpressionFunctions.registerChartInstance(vega, this.chartID, chartOptions);\n\n\t\t//TODO: embed the vega chart into the dom\n\t\tconst vegaSpec = this.getChartConfig(chartOptions);\n    //const embedOpts = { renderer: this.renderer, actions: false, tooltip: tooltipCallback };\n    const embedOpts = {tooltip: tooltipCallback}; \n\n\t\t// vegaEmbed will generate the canvas, and add the canvas to vegaContainer\n\t\t// it will also remove all children from vegaContainer beforehand (so it will remove the loading spinner we added)\n    // see here: https://github.com/vega/vega-embed/blob/940c44c1051ae2138cf00e05e2a8b05c1ece25bd/src/embed.ts#L296\n\t\tconst vegaView = await vegaEmbed(vegaContainer, vegaSpec, embedOpts);\n\n\t\t// because the vegaEmbed func is async, finalize any renders we cancelled above\n\t\t// if not cancelled, set as the new this.vegaView\n\t\tif (this.isCancelledRender(currentRenderId)) {\n\t\t\tvegaView.view.finalize();\n\t\t\tvegaView.view.container().remove();\n\t\t} else {\n      this.vegaView = vegaView;\n    } \n\t}\n\n\tshouldShowLoadingState(opts) {\n\t\t//use a hueristic to decide to show a loading spinner - only show for big data sets\n\t\t//for example concurrent viewers panel can have 15000 data points\n\t\t//let totalDataPoints = (opts.dataSets?.length ?? 0) * (opts.dataSets?.[0]?.data?.length ?? 0);\n    //return totalDataPoints > 10000;\n\n    // TODO: DECIDE LATER ON WHAT CONDITIONS TO SHOW A LOADING INDICATOR.\n    return true;\n  }  \n  \n\t// since vegaEmbed is async, allow for cancelling pending renders\n\t// if two render calls come in, we want the last one in to be what renders on the page\n\t// imagine an example where call \"A\" comes in, then \"B\", but B finishes async work before A.  We want A to be cancelled so that B is what gets rendered on the page\n\tcancelPendingRenders({ newPendingRenderId }) {\n\t\tthis.lastRenderId = newPendingRenderId;\n  }\n\n\tisCancelledRender(renderId) {\n\t\treturn renderId !== this.lastRenderId;\n  }\n \n\tdestroy() {\n\t\tif (this.vegaView) {\n\t\t\tthis.vegaView.view.finalize();\n\t\t\tthis.vegaView.view.container().remove();\n    }\n  }\n\n  /* \n\tvalidate() {\n\t\t// An array of datasets is required\n\t\tif (!this.dataSets) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst representativeData = this.dataSets[0]?.data?.[0];\n\n\t\t// Check that the first element is time\n\t\t// This still allows an empty dataset to pass\n\t\tif (representativeData && !(representativeData.value('x') instanceof Date)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn super.validate(this._opts.dataSets);\n  }\n  */ \n\n\tgetChartConfig(opts) {\n\t\tlet config = {\n      $schema: 'https://vega.github.io/schema/vega/v5.json',\n      // Fit within width/height, with width/height being the total.\n\t\t\tautosize: { type: 'fit', contains: 'padding' },\n\t\t\tpadding: opts.padding,\n\t\t\tbackground: getConstants().vizBackgroundColor,\n\t\t\twidth: opts.width,\n\t\t\theight: opts.height,\n\t\t\tdata: opts.formattedData,\n\t\t\tsignals: ForceDirectedSignals.create(opts),\n\t\t\tmarks: ForceDirectedMarks.create(opts),\n\t\t\tscales: ForceDirectedScales.create(opts),\n      config: {}\n\t\t};\n\n\t\treturn config;\n  } \n\n\tget padding() {\n    // Hardcoded values for now...\n    return { left: 0, top: 0, right: 0, bottom: 0 };\n\t}\n\n  /* \n\tgetMaxDataSetLength() {\n\t\tif (!this.dataSets.length) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst longestDataSet = _.max(this.dataSets, ds => ds.data.length);\n\t\treturn longestDataSet.data.length;\n\t}\n\n\n\tgetPrecision(input) {\n\t\tconst metricFormatter = new MetricFormatter();\n\t\treturn metricFormatter.getCurrentPrecision(input);\n\t}\n\n\tcontainsAnomalyData() {\n\t\treturn this.dataSets.some(ds => ds.data.some(d => d.value('upperConfidenceBound')));\n\t}\n\n\tget dataSets() {\n\t\treturn this.opts.dataSets;\n\t}\n\n\tget anomaliesEnabled() {\n\t\treturn this.opts.showAnomalies && this.containsAnomalyData();\n\t}\n\n\tget anomalyRescaleIsEnabled() {\n\t\treturn this.opts.allowAnomaliesToRescale && this.anomaliesEnabled;\n\t}\n\n\tget dualYAxisIsEnabled() {\n\t\treturn this.opts.dualYAxis && this.dataSets.length === 2;\n\t}\n\n\tget normalizedIsEnabled() {\n\t\treturn this.opts.normalized && this.dataSets.length >= 2;\n\t}\n\n\tget normalizationRequired() {\n\t\treturn this.normalizedIsEnabled || this.dualYAxisIsEnabled;\n\t}\n\n\tget showMaxMinLabels() {\n\t\treturn this.opts.showMax || this.opts.showMin;\n\t}\n\n\tget showNormalizedAxis() {\n\t\treturn this.normalizedIsEnabled;\n\t}\n\n\tget renderer() {\n\t\t//render differently depending where the chart will be rendered (svg for PDF, canvas for HTML)\n\t\t//canvas won't scale well in PDF as the user resizes the PDF.  SVG lets the PDF redraw certain nodes (eg text) so they look crisp\n\t\t//SVG adds a lot of dom nodes that will slow down a browser page, using canvas cuts down to just one dom node\n\t\treturn this.opts.serverRender ? 'svg' : 'canvas';\n\t}\n\n\thighlightDataByIds(ids = []) {\n\t\t// TODO: Needs to be implemented differently from CloudViz since we don't have the DOM to manipulate\n\t}\n  */\n}\n\nChartFactory.registerChart(ForceDirected);\n"],"sourceRoot":""}